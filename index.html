<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–í–∏–ø—Ä–∞–≤–ª–µ–Ω–Ω—è –ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤–∏</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        function PerspectiveCorrector() {
          const [image, setImage] = useState(null);
          const [corners, setCorners] = useState([]);
          const [draggingCorner, setDraggingCorner] = useState(null);
          const [result, setResult] = useState(null);
          const canvasRef = useRef(null);
          const resultCanvasRef = useRef(null);

          useEffect(() => {
            if (image && canvasRef.current) {
              drawCanvas();
            }
          }, [image, corners]);

          const handleImageUpload = (e) => {
            const file = e.target.files[0];
            if (file) {
              const reader = new FileReader();
              reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                  setImage(img);
                  const w = img.width;
                  const h = img.height;
                  const margin = Math.min(w, h) * 0.1;
                  setCorners([
                    { x: margin, y: margin },
                    { x: w - margin, y: margin },
                    { x: w - margin, y: h - margin },
                    { x: margin, y: h - margin }
                  ]);
                  setResult(null);
                };
                img.src = event.target.result;
              };
              reader.readAsDataURL(file);
            }
          };

          const drawCanvas = () => {
            const canvas = canvasRef.current;
            const ctx = canvas.getContext('2d');
            
            if (!image) return;

            const maxWidth = 800;
            const scale = Math.min(maxWidth / image.width, 1);
            canvas.width = image.width * scale;
            canvas.height = image.height * scale;

            ctx.drawImage(image, 0, 0, canvas.width, canvas.height);

            if (corners.length === 4) {
              ctx.strokeStyle = '#3b82f6';
              ctx.lineWidth = 3;
              ctx.beginPath();
              corners.forEach((corner, i) => {
                const x = corner.x * scale;
                const y = corner.y * scale;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
              });
              ctx.closePath();
              ctx.stroke();

              corners.forEach((corner, i) => {
                const x = corner.x * scale;
                const y = corner.y * scale;
                ctx.fillStyle = '#3b82f6';
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(i + 1, x, y);
              });
            }
          };

          const handleCanvasClick = (e) => {
            if (!image) return;
            
            const canvas = canvasRef.current;
            const rect = canvas.getBoundingClientRect();
            const scale = canvas.width / rect.width;
            const x = (e.clientX - rect.left) * scale;
            const y = (e.clientY - rect.top) * scale;
            
            const imageScale = image.width / canvas.width;
            const actualX = x * imageScale;
            const actualY = y * imageScale;

            const clickRadius = 15;
            const clickedCornerIndex = corners.findIndex(corner => {
              const dx = corner.x - actualX;
              const dy = corner.y - actualY;
              return Math.sqrt(dx * dx + dy * dy) < clickRadius * imageScale;
            });

            if (clickedCornerIndex >= 0) {
              setDraggingCorner(clickedCornerIndex);
            }
          };

          const handleCanvasMove = (e) => {
            if (draggingCorner === null || !image) return;

            const canvas = canvasRef.current;
            const rect = canvas.getBoundingClientRect();
            const scale = canvas.width / rect.width;
            const x = (e.clientX - rect.left) * scale;
            const y = (e.clientY - rect.top) * scale;
            
            const imageScale = image.width / canvas.width;
            const actualX = Math.max(0, Math.min(x * imageScale, image.width));
            const actualY = Math.max(0, Math.min(y * imageScale, image.height));

            const newCorners = [...corners];
            newCorners[draggingCorner] = { x: actualX, y: actualY };
            setCorners(newCorners);
          };

          const handleCanvasUp = () => {
            setDraggingCorner(null);
          };

          const applyPerspectiveTransform = () => {
            if (!image || corners.length !== 4) return;

            const sorted = [...corners];
            sorted.sort((a, b) => a.y - b.y);
            const top = sorted.slice(0, 2).sort((a, b) => a.x - b.x);
            const bottom = sorted.slice(2, 4).sort((a, b) => a.x - b.x);
            const orderedCorners = [top[0], top[1], bottom[1], bottom[0]];

            const width1 = Math.sqrt(
              Math.pow(orderedCorners[1].x - orderedCorners[0].x, 2) +
              Math.pow(orderedCorners[1].y - orderedCorners[0].y, 2)
            );
            const width2 = Math.sqrt(
              Math.pow(orderedCorners[2].x - orderedCorners[3].x, 2) +
              Math.pow(orderedCorners[2].y - orderedCorners[3].y, 2)
            );
            const height1 = Math.sqrt(
              Math.pow(orderedCorners[3].x - orderedCorners[0].x, 2) +
              Math.pow(orderedCorners[3].y - orderedCorners[0].y, 2)
            );
            const height2 = Math.sqrt(
              Math.pow(orderedCorners[2].x - orderedCorners[1].x, 2) +
              Math.pow(orderedCorners[2].y - orderedCorners[1].y, 2)
            );

            const maxWidth = Math.round(Math.max(width1, width2));
            const maxHeight = Math.round(Math.max(height1, height2));

            const resultCanvas = resultCanvasRef.current;
            resultCanvas.width = maxWidth;
            resultCanvas.height = maxHeight;
            const ctx = resultCanvas.getContext('2d');

            const srcCorners = orderedCorners;
            transformImage(image, ctx, maxWidth, maxHeight, srcCorners);

            setResult(resultCanvas.toDataURL());
          };

          const transformImage = (img, ctx, width, height, srcCorners) => {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = img.width;
            tempCanvas.height = img.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(img, 0, 0);
            const imageData = tempCtx.getImageData(0, 0, img.width, img.height);

            const resultData = ctx.createImageData(width, height);

            for (let y = 0; y < height; y++) {
              for (let x = 0; x < width; x++) {
                const srcPoint = mapPoint(x, y, width, height, srcCorners);
                
                if (srcPoint.x >= 0 && srcPoint.x < img.width && 
                    srcPoint.y >= 0 && srcPoint.y < img.height) {
                  const srcX = Math.floor(srcPoint.x);
                  const srcY = Math.floor(srcPoint.y);
                  const srcIdx = (srcY * img.width + srcX) * 4;
                  const dstIdx = (y * width + x) * 4;

                  resultData.data[dstIdx] = imageData.data[srcIdx];
                  resultData.data[dstIdx + 1] = imageData.data[srcIdx + 1];
                  resultData.data[dstIdx + 2] = imageData.data[srcIdx + 2];
                  resultData.data[dstIdx + 3] = imageData.data[srcIdx + 3];
                }
              }
            }

            ctx.putImageData(resultData, 0, 0);
          };

          const mapPoint = (x, y, width, height, srcCorners) => {
            const u = x / width;
            const v = y / height;

            const top = {
              x: srcCorners[0].x * (1 - u) + srcCorners[1].x * u,
              y: srcCorners[0].y * (1 - u) + srcCorners[1].y * u
            };
            const bottom = {
              x: srcCorners[3].x * (1 - u) + srcCorners[2].x * u,
              y: srcCorners[3].y * (1 - u) + srcCorners[2].y * u
            };

            return {
              x: top.x * (1 - v) + bottom.x * v,
              y: top.y * (1 - v) + bottom.y * v
            };
          };

          const downloadResult = () => {
            if (!result) return;
            const link = document.createElement('a');
            link.download = 'corrected-image.png';
            link.href = result;
            link.click();
          };

          const reset = () => {
            if (image) {
              const w = image.width;
              const h = image.height;
              const margin = Math.min(w, h) * 0.1;
              setCorners([
                { x: margin, y: margin },
                { x: w - margin, y: margin },
                { x: w - margin, y: h - margin },
                { x: margin, y: h - margin }
              ]);
              setResult(null);
            }
          };

          return (
            <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-8">
              <div className="max-w-6xl mx-auto">
                <h1 className="text-4xl font-bold text-gray-800 mb-2 text-center">
                  –í–∏–ø—Ä–∞–≤–ª–µ–Ω–Ω—è –ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤–∏
                </h1>
                <p className="text-gray-600 mb-8 text-center">
                  –ó–∞–≤–∞–Ω—Ç–∞–∂—Ç–µ —Ñ–æ—Ç–æ —Ç–∞ –ø–µ—Ä–µ—Ç—è–≥–Ω—ñ—Ç—å –∫—É—Ç–∏ –¥–ª—è –≤–∏–ø—Ä–∞–≤–ª–µ–Ω–Ω—è –≤–∏–∫—Ä–∏–≤–ª–µ–Ω–Ω—è
                </p>

                <div className="bg-white rounded-xl shadow-lg p-6 mb-6">
                  <div className="flex flex-wrap gap-4 mb-6">
                    <label className="flex-1 min-w-[200px]">
                      <div className="flex items-center justify-center gap-2 bg-blue-500 hover:bg-blue-600 text-white px-6 py-3 rounded-lg cursor-pointer transition">
                        <span>üì§ –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ —Ñ–æ—Ç–æ</span>
                      </div>
                      <input
                        type="file"
                        accept="image/*"
                        onChange={handleImageUpload}
                        className="hidden"
                      />
                    </label>

                    {image && (
                      <>
                        <button
                          onClick={reset}
                          className="flex items-center gap-2 bg-gray-500 hover:bg-gray-600 text-white px-6 py-3 rounded-lg transition"
                        >
                          <span>üîÑ –°–∫–∏–Ω—É—Ç–∏</span>
                        </button>
                        <button
                          onClick={applyPerspectiveTransform}
                          className="flex items-center gap-2 bg-green-500 hover:bg-green-600 text-white px-6 py-3 rounded-lg transition"
                        >
                          <span>‚ú® –í–∏–ø—Ä–∞–≤–∏—Ç–∏ –ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤—É</span>
                        </button>
                      </>
                    )}

                    {result && (
                      <button
                        onClick={downloadResult}
                        className="flex items-center gap-2 bg-indigo-500 hover:bg-indigo-600 text-white px-6 py-3 rounded-lg transition"
                      >
                        <span>üíæ –ó–±–µ—Ä–µ–≥—Ç–∏</span>
                      </button>
                    )}
                  </div>

                  {image && (
                    <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6">
                      <p className="text-sm text-blue-800">
                        <strong>–Ü–Ω—Å—Ç—Ä—É–∫—Ü—ñ—è:</strong> –ü–µ—Ä–µ—Ç—è–≥–Ω—ñ—Ç—å —Å–∏–Ω—ñ —Ç–æ—á–∫–∏ –Ω–∞ –∫—É—Ç–∏ –æ–±'—î–∫—Ç–∞, —è–∫–∏–π –ø–æ—Ç—Ä—ñ–±–Ω–æ –≤–∏–ø—Ä—è–º–∏—Ç–∏. 
                        –¢–æ—á–∫–∏ –ø—Ä–æ–Ω—É–º–µ—Ä–æ–≤–∞–Ω—ñ 1-4 –∑–∞ –≥–æ–¥–∏–Ω–Ω–∏–∫–æ–≤–æ—é —Å—Ç—Ä—ñ–ª–∫–æ—é, –ø–æ—á–∏–Ω–∞—é—á–∏ –∑ –≤–µ—Ä—Ö–Ω—å–æ–≥–æ –ª—ñ–≤–æ–≥–æ –∫—É—Ç–∞.
                      </p>
                    </div>
                  )}

                  <div className="grid md:grid-cols-2 gap-6">
                    {image && (
                      <div>
                        <h3 className="font-semibold text-gray-700 mb-3">–û—Ä–∏–≥—ñ–Ω–∞–ª (–ø–µ—Ä–µ—Ç—è–≥–Ω—ñ—Ç—å —Ç–æ—á–∫–∏)</h3>
                        <div className="border-2 border-gray-300 rounded-lg overflow-hidden bg-gray-100">
                          <canvas
                            ref={canvasRef}
                            onMouseDown={handleCanvasClick}
                            onMouseMove={handleCanvasMove}
                            onMouseUp={handleCanvasUp}
                            onMouseLeave={handleCanvasUp}
                            className="w-full cursor-crosshair"
                          />
                        </div>
                      </div>
                    )}

                    {result && (
                      <div>
                        <h3 className="font-semibold text-gray-700 mb-3">–í–∏–ø—Ä–∞–≤–ª–µ–Ω–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç</h3>
                        <div className="border-2 border-green-300 rounded-lg overflow-hidden bg-gray-100">
                          <img src={result} alt="Result" className="w-full" />
                        </div>
                      </div>
                    )}
                  </div>

                  <canvas ref={resultCanvasRef} className="hidden" />
                </div>

                <div className="bg-white rounded-xl shadow-lg p-6">
                  <h3 className="font-semibold text-gray-700 mb-3">–ü–æ—Ä–∞–¥–∏ –¥–ª—è –∫—Ä–∞—â–æ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É:</h3>
                  <ul className="space-y-2 text-gray-600">
                    <li>‚Ä¢ –§–æ—Ç–æ–≥—Ä–∞—Ñ—É–π—Ç–µ –≤ –¥–æ–±—Ä–µ –æ—Å–≤—ñ—Ç–ª–µ–Ω–æ–º—É –º—ñ—Å—Ü—ñ</li>
                    <li>‚Ä¢ –ö–æ–Ω—Ç—Ä–∞—Å—Ç–Ω–∏–π —Ñ–æ–Ω –ø–æ–ª–µ–≥—à–∏—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–µ –≤–∏—è–≤–ª–µ–Ω–Ω—è</li>
                    <li>‚Ä¢ –ü–µ—Ä–µ—Ç—è–≥—É–π—Ç–µ —Ç–æ—á–∫–∏ —è–∫–æ–º–æ–≥–∞ —Ç–æ—á–Ω—ñ—à–µ –Ω–∞ –∫—É—Ç–∏ –æ–±'—î–∫—Ç–∞</li>
                    <li>‚Ä¢ –î–ª—è –∫–∞—Ä—Ç–æ–∫ —Ç–∞ —ñ–≥—Ä–æ–≤–∏—Ö –ø–æ–ª—ñ–≤ –Ω–∞–º–∞–≥–∞–π—Ç–µ—Å—è —Ç—Ä–∏–º–∞—Ç–∏ –∫–∞–º–µ—Ä—É –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –ø–∞—Ä–∞–ª–µ–ª—å–Ω–æ –ø–æ–≤–µ—Ä—Ö–Ω—ñ</li>
                  </ul>
                </div>
              </div>
            </div>
          );
        }

        ReactDOM.render(<PerspectiveCorrector />, document.getElementById('root'));
    </script>
</body>
</html>
